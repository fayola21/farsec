ClassCastException when using camel-cxf and camel-jms in the InOut same flow    As per thread on FUSE forum http://fusesource.com/forums/thread.jspa?threadID=834&amp;tstart=0:[[I have a camel route that listens on a CXFEndpoint (for MESSAGE data as DOMSource) and routes the message to a JMS queue. Something like:&lt;route&gt;&lt;from uri='cxf:bean:passportRequestWS?dataFormat=MESSAGE'/&gt;&lt;to uri='soapProcessor'/&gt;&lt;convertBodyTo type='java.lang.String'/&gt;&lt;to uri='activemq:queue:blah'/&gt;&lt;convertBodyTo type='javax.xml.transform.dom.DOMSource'/&gt;&lt;/route&gt;My understanding is that the JMS producer will realize that the exchange is InOut  create a temporary queue for the response  and then wait for the response to arrive on the temporary queue before sending the original CXFExchange on along the pipeline. Indeed  this is what I observe! However  I?ve discovered a little nasty.When the JMSProducer gets in the incoming message  it sets the Out message of the original CXFExchange to a JmsMessage. Then  the pipeline processor calls exchange.getOut on the CXFExchange and BANG! we get a class-cast exception. Turns out that the CXFExchange.getOut() method always casts the message to a CxfMessage. Ouch. Surely this means then that camel-cxf can?t talk to any producer that does not produce a CXFMessage - very limiting.]]The response on the form from davsclaus was:[[Well spotted.If just the damn Exchange was final so we had one implementation of it. But I guess we have to thank Java generics for that so the first API had generics for per component.Could you create a ticket in JIRA for this?As a workaround you can add a processor where you have full access to the Exchange so you can set a CxfMessage as the payload.]]   
<title>Issue 12965 -   chromium -    Race condition during ExtensionsService shutdown - Project Hosting on Google Code</title> <pre> In the current code  ExtensionsService holds a reference to   ExtensionsServiceBackend which runs on the file thread. Whenever   ExtensionsService needs the backend to do something  it posts a task to it   along with a scoped_refptr to itself  which gets set into the frontend_   naked pointer. But since Matt's recent changes to post jobs from the   backend to the utility process  at shutdown we could have the situation   that the frontend gets deleted and calls Deref on the backend  but utility   process holds a reference to the backend for a task it's currently   executing  so the backend still is alive with a naked pointer to the freed   frontend. When the backend gets a callback from the utility process  it may   try to post a task using the (now invalid) frontend pointer.    The extensions auto-update code I'm working on has a similar issue  since   it uses a ExtensionUpdater object referenced by the ExtensionsService  but   posts tasks to the file thread  and will eventually post tasks to the   utility process as well.    Matt  Erik and I discussed this today and came up with a couple of   different ways to solve it. One is to use a status object referenced by   both the frontend and backend  which the frontend can notify as it goes out   of scope. Then every backend-&gt;frontend task post has to check the status   object to see if it can still post a task; this may need to use some   locking. Another idea is to do something using a ScopedTaskFactory  or   along those same lines.    Where we left it is that I'll file this bug and then post to chromium-dev   to get some opinions; Erik mentioned that abarth did a bunch of the Task   stuff so he might have a good suggestion for an elegant way to handle this.      </pre>
<title>Issue 8325 -   chromium -    NTLM authentication to a proxy doesn't work if Privoxy sits in between - Project Hosting on Google Code</title> <pre> After I checked in our NTLM authentication code in <a href="/p/chromium/source/detail?r=10667">r10667</a>  igitur reported   this problem in <a title="URL's fail to load if behind a proxy in 2.0.157.2" class=closed_ref href="/p/chromium/issues/detail?id=6567"> issue 6567 </a>#c23.  He said (reordered by me for clarity):      I use Privoxy on my office PC which forwards requests the    company proxy  which in turn requires NTLM authentication.    Privoxy itself isn't explicitly configured to require any    sort of authentication.      I looked at the traffic with Wireshark and it seems the full    NTLM cycle isn't completed.    I suspect that Privoxy may have rewritten some response headers from the   proxy  so that Chromium thinks the connection is not keep-alive and opens a   new connection for the second half of the NTLM cycle.  This is done in HttpNetworkTransaction::PrepareForAuthRestart:      bool keep_alive = false;    if (response_.headers-&gt;IsKeepAlive()) {      // If there is a response body of known length  we need to drain it   first.      if (content_length_ &gt; 0 || chunked_decoder_.get()) {        next_state_ = STATE_DRAIN_BODY_FOR_AUTH_RESTART;        read_buf_ = new IOBuffer(kDrainBodyBufferSize);  // A bit bucket        read_buf_len_ = kDrainBodyBufferSize;        return;      }      if (content_length_ == 0)  // No response body to drain.        keep_alive = true;      // content_length_ is -1 and we're not using chunked encoding.  We   don't      // know the length of the response body  so we can't reuse this   connection      // even though the server says it's keep-alive.    }      // We don't need to drain the response body  so we act as if we had   drained    // the response body.    DidDrainBodyForAuthRestart(keep_alive);    So we can try changing the outermost if test to:      if (response_.headers-&gt;IsKeepAlive() ||        auth_handler_[target]-&gt;is_connection_based()) {    Darin  do you know if this is what Firefox does?  For connection-based auth   schemes  does Firefox ignore any HTTP/1.1 &quot;Connection: close&quot; or &quot;Proxy-  Connection: close&quot; response header?  (Or equivalently  for HTTP/1.0   responses  does Firefox tolerate missing &quot;Connection: keep-alive&quot; or   &quot;Proxy-Connection: keep-alive&quot; headers?) </pre>
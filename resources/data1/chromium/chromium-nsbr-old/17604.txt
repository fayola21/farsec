<title>Issue 17604 -   chromium -    Browser crash after critical disk cache error. - Project Hosting on Google Code</title> <pre> http://crash/reportdetail?  reportid=1f79fcea91b3eceb&amp;product=Chrome&amp;version=3.0.195.1&amp;date=&amp;signature=disk_cache::BackendImpl::MatchEntry(std::basi  c_string&lt;char std::char_traits&lt;char&gt; std::allocator&lt;char&gt;+&gt;+const+%26 unsigned+int bool)-1D7C233    [backend_impl.cc:1187]   Disk_cache::BackendImpl::MatchEntry(std::basic_string&lt;char std::char_traits&lt;char&gt; std::allocator&lt;char&gt; &gt; const   &amp; unsigned int bool)  [backend_impl.cc:373]	   disk_cache::BackendImpl::OpenEntry(std::basic_string&lt;char std::char_traits&lt;char&gt; std::allocator&lt;char&gt; &gt; const   &amp; disk_cache::Entry * *)  [http_cache.cc:557]	 net::HttpCache::Transaction::AddToEntry()  [http_cache.cc:395]	 net::HttpCache::Transaction::Start(net::HttpRequestInfo const * CallbackRunner&lt;Tuple1&lt;int&gt; &gt; *)  [url_request_http_job.cc:599]	 URLRequestHttpJob::StartTransaction()  [url_request_http_job.cc:146]	 URLRequestHttpJob::Start()          if (!error) {          // It is important to call DestroyInvalidEntry after removing this          // entry from the table.          DestroyInvalidEntry(cache_entry);          cache_entry = NULL;        } else {          Trace(&quot;NewEntry failed on MatchEntry 0x%x&quot;  address.value());        }          // Restart the search.        address.set_value(data_-&gt;table[hash &amp; mask_]);        continue;    The problem is that cache_entry = NULL may release the last reference to an entry so if we detected a critical failure   (we are after all cleaning up a corrupt entry)  the cache can be restarted  so we have to check for disabled_ before   accessing the table again.   </pre>
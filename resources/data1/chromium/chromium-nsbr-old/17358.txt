<title>Issue 17358 -   chromium -    ChildThread::~ChildThread() leaks an IPC channel on posix - Project Hosting on Google Code</title> <pre> valgrind now complains in ui tests as follows:    10 486 (156 direct  10 330 indirect) bytes in 1 blocks are definitely lost in loss record 381 of  386    operator new(unsigned int) (ome/chrome-bot/valgrind-10414-vex-1906-    IPC::SyncChannel::SyncChannel(std::basic_string&lt;char  std::char_traits&lt;char&gt;   std::allocator&lt;char&gt; &gt; const&amp;  IPC::Channel::Mode  IPC::Channel::Listener*   IPC::ChannelProxy::MessageFilter*  MessageLoop*  bool  base::WaitableEvent*)  (chrome/common/ipc_sync_channel.cc:347)    ChildThread::ChildThread() (chrome/common/child_thread.cc:33)    RenderThread::RenderThread() (chrome/renderer/render_thread.cc:91)    RendererMain(MainFunctionParams const&amp;) (chrome/renderer/renderer_main.cc:123)    ChromeMain (chrome/app/chrome_dll_main.cc:491)    main (chrome/app/chrome_exe_main_gtk.cc:33)    The leak is partially intentional.  ChildThread::~ChildThread() has a comment that reads      // The ChannelProxy object caches a pointer to the IPC thread  so need to    // reset it as it's not guaranteed to outlive this object.    // NOTE: this also has the side-effect of not closing the main IPC channel to    // the browser process.  This is needed because this is the signal that the    // browser uses to know that this process has died  so we need it to be alive    // until this process is shut down  and the OS closes the handle    // automatically.  We used to watch the object handle on Windows to do this     // but it wasn't possible to do so on POSIX.    Filing bug and suppression per usual procedure  marking bug wontfix per the comment. </pre>
<title>Issue 15055 -   chromium -    Data race in base/directory_watcher_inotify.cc - Project Hosting on Google Code</title> <pre> Chrome Version       : svn <a href="/p/chromium/source/detail?r=18944">r18944</a>  OS + version : Linux      1. Apply the following patch. The data race exists without this sleep  but  the sleep helps re-produce the race.  Index: base/directory_watcher_inotify.cc  ===================================================================  --- base/directory_watcher_inotify.cc	(<a href="/p/chromium/source/detail?r=18944">revision 18944</a>)  +++ base/directory_watcher_inotify.cc	(working copy)  @@ -416 6 +416 7 @@       }     }     recursive_setup_finished_.Signal();  +  sleep(10);     return success;   }     2. hammer base_unittests  3. ./sconsbuild/Debug/base_unittests  --gtest_filter=&quot;DirectoryWatcherTest.BackendLoop&quot;      Test must pass      It crashes on an assertion  [...base/lock_impl_posix.cc(31)] Check failed: rv == 0 (16 vs. 0)    Using ThreadSanitizer (see  <a href="http://code.google.com/p/data-race-test/wiki/ThreadSanitizer">http://code.google.com/p/data-race-test/wiki/ThreadSanitizer</a>) I got the  following reports:    ==24005== WARNING: Lock L382 was released by thread T0 which did not  acquire this lock.  ==24005==     #0  pthread_mutex_destroy  ==24005==     #1  LockImpl::~LockImpl() base/lock_impl_posix.cc:30  ==24005==     #2  Lock::~Lock() base/lock.h:15  ==24005==     #3  (anonymous  namespace)::DirectoryWatcherImpl::~DirectoryWatcherImpl()  base/directory_watcher_inotify.cc:369  ==24005==     #4   base::RefCounted&lt;DirectoryWatcher::PlatformDelegate&gt;::Release()  base/ref_counted.h:80  ==24005==     #5   scoped_refptr&lt;DirectoryWatcher::PlatformDelegate&gt;::~scoped_refptr()  base/ref_counted.h:196  ==24005==     #6  DirectoryWatcher::~DirectoryWatcher()  base/directory_watcher.h:28  ==24005==     #7  (anonymous  namespace)::DirectoryWatcherTest_BackendLoop_Test::TestBody()  base/directory_watcher_unittest.cc:291  ==24005==  ==24005== WARNING: Unlocking a non-locked lock L382 in thread T62  ==24005==     #0  pthread_mutex_unlock  ==24005==     #1  LockImpl::Unlock() base/lock_impl_posix.cc:46  ==24005==     #2  Lock::Release() base/lock.h:17  ==24005==     #3  AutoLock::~AutoLock() base/lock.h:48  ==24005==     #4  (anonymous  namespace)::DirectoryWatcherImpl::OnEnumeratedSubtree(std::set&lt;FilePath   std::less&lt;FilePath&gt;  std::allocator&lt;FilePath&gt; &gt; const&amp;)  base/directory_watcher_inotify.cc:419  ==24005==     #5  (anonymous namespace)::RegisterSubtreeWatchesTask::Run()  base/directory_watcher_inotify.cc:163  ==24005==     #6  MessageLoop::RunTask(Task*) base/message_loop.cc:309  ==24005==     #7   MessageLoop::DeferOrRunPendingTask(MessageLoop::PendingTask const&amp;)  base/message_loop.cc:317  ==24005==     #8  MessageLoop::DoWork() base/message_loop.cc:423  ==24005==     #9   base::MessagePumpDefault::Run(base::MessagePump::Delegate*)  base/message_pump_default.cc:23  ==24005==     #10 MessageLoop::RunInternal() base/message_loop.cc:198  ==24005==     #11 MessageLoop::RunHandler() base/message_loop.cc:181  ==24005==     #12 MessageLoop::Run() base/message_loop.cc:155  ==24005==     #13 base::Thread::ThreadMain() base/thread.cc:156  ==24005==     #14 ThreadFunc(void*) base/platform_thread_posix.cc:26    The problem is AutoLock unlocking its Lock that was already deleted (also   it was deleted while it was still locked). </pre>
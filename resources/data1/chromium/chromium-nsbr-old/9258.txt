<title>Issue 9258 -   chromium -    Review the two WaitForSingleObject(INFINITE) calls in tcp_client_socket_win.cc - Project Hosting on Google Code</title> <pre> tcp_client_socket_win.cc has two WaitForSingleObject calls with  INFINITE timeout.  I need to review those two calls.  Ideally  they should not block the IO thread indefinitely if Windows or  some other thread is malfunctioning.    The first call is in TCPClientSocket::Disconnect():      // Cancel any pending IO and wait for it to be aborted.    if (wait_state_ == WAITING_READ || wait_state_ == WAITING_WRITE) {      CancelIo(reinterpret_cast&lt;HANDLE&gt;(socket_));      WaitForSingleObject(overlapped_.hEvent  INFINITE);      wait_state_ = NOT_WAITING;    }    Here we call WaitForSingleObject on the IO thread because we often  get here via the TCPClientSocket destructor  and the caller of  the TCPClientSocket destructor expects a synchronous socket closure.    The second call to WaitForSingleObject is in  TCPClientSocket::WaitForAndResetEvent():      DWORD wait_rv = WaitForSingleObject(overlapped_.hEvent  INFINITE);    CHECK(wait_rv == WAIT_OBJECT_0);    BOOL ok = WSAResetEvent(overlapped_.hEvent);    CHECK(ok);    Here we call WaitForSingleObject on the IO thread as a performance  optimization  to avoid a thread context switch.  It is straightforward  to move this WaitForSingleObject call to the thread pool.         </pre>
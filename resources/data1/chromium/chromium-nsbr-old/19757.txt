<title>Issue 19757 -   chromium -    syncapi shutdown blocks UI in janky way - Project Hosting on Google Code</title> <pre> [warning  this is complicated]    Background:  Sync has a dedicated thread (syncer thread) that handles incoming messages   from sync servers and performs conflict resolution.  In normal operation    the syncer thread produces work for the UI thread to perform (i.e   BookmarkModel operations to apply changes) and blocks itself until the work   is finished.  This is handled through the sync/glue/BookmarkModelWorker   class.  A fun scenario comes up when we want to tell the syncapi (and hence   the syncer thread) to shutdown. This happens     1) at Chrome shutdown  when the profile object is deleted (which deletes   the sync service  which shuts down the syncapi ...) by ~BrowserProcessImpl     2) when the user clicks 'Stop Syncing this account' to disable sync.    The Problem:    Shutting down the syncer thread is done via &quot;quit ASAP&quot; semantics  where it   finishes up whatever it was doing and exits.  This means it can produce   work for the UI thread after being told to shutdown.  In case (2) in   general  this isn't really a problem.  But case (1) is a world of hurt   because ~BrowserProcessImpl is invoked after the MessageLoop on the UI   thread has quit (see the call to browser_process.release() at the bottom of   browser_main.cc).  So just calling shutdown would cause the syncer thread   to lock up on shutdown.    What we do right now is intercept any work that comes from the syncer   thread after we've told it to shutdown and execute it manually (see   BookmarkModelWorker::Stop)  and act as a MessageLoop.  But this means we   have to block the UI thread (note there is no ui MessageLoop in (1)) and do   this &quot;manual pumping&quot; until the syncer thread exits.  At chrome exit    blocking the UI like this is fine (at this point it just wants to exit so   it has to wait)  but in case (2) this really blows.    The best way out that I see  and I've cc'ed jar and darin for expert   opinions  is if we had a way for a MessageLoop observer to know when the   loop is about to *exit* and not just *be destroyed*.  Then  we could assume   we always have a MessageLoop to handle the dying requests of the syncer   thread because when we got such a notification we could kick off shutdown.    Then we would not have to block in case (2).  In fact I seem to think this   would be way more useful to a MessageLoop observer  to know &quot;hey  this is   your last chance to do anything&quot;.     </pre>
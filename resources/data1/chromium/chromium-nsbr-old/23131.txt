<title>Issue 23131 -   chromium -    Large XMLHttpRequest responses are very slow and use too much memory - Project Hosting on Google Code</title> <pre> When an XMLHttpRequest's response is large (&gt;50K or so) it comes up from the resource loader in multiple chunks of a few K each.  Each chunk is   passed up to XMLHttpRequest::didReceiveData() where it is re-encoded into UTF-16 and then appended to m_responseText using operator +=.  Then a   readystatechange event is dispatched to JavaScript at which time the JavaScript might query the length or contents of m_responseText.   m_responseText is a ScriptString object  the comments in XMLHttpRequest.h explain why:        // Unlike most strings in the DOM  we keep this as a ScriptString  not a WebCore::String.      // That's because these strings can easily get huge (they are filled from the network with      // no parsing) and because JS can easily observe many intermediate states  so it's very useful      // to be able to share the buffer with JavaScript versions of the whole or partial string.      // In contrast  this string doesn't interact much with the rest of the engine so it's not that      // big a cost that it isn't a String.      ScriptString m_responseText;    In JSC-enabled builds  ScriptString is backed by a JSC::UString object which supports cheap appends (by reserving extra capacity) and allows for   the JS heap to have multiple references to substrings that all point to the same backing buffer with different lengths.  This means that the   normal case where on each didReceiveData() call the JS land onreadystatechange handler either does not query responseText or only queries   responseText.length no string copies are needed and life is beautiful.    Unfortunately in Chromium ScriptString is actually backed by a WebCore::String which is immutable so each append operation calls String::append()   which does a malloc() and a memcopy() of the entire buffer for each append operation.  Generally the pre-append String is then deleted  but since   JavaScript has the opportunity to query the responseText field V8 might grab a reference to the WebCore::String on each readystatechange event.    Since they are all backed by different buffers this could lead to O(N*M) memory use where N is the size of the final request and M is the number   of didReceiveData() calls  which depends on how data is received from the network layer.  This memory stays alive until the string handle in V8 is   collected. </pre>
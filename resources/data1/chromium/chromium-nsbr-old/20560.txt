<title>Issue 20560 -   chromium -    Embedded username/password in URLs that require NTLM authentication will be used repeatedly. - Project Hosting on Google Code</title> <pre> In http_network_transaction.cc  we have the following code to  ensure that we use embedded username/password in the URL only  once for the HTTP transaction:      // Try to use the username/password encoded into the URL first.    // (By checking source == IDENT_SRC_NONE  we make sure that this    // is only done once for the transaction.)    if (target == HttpAuth::AUTH_SERVER &amp;&amp; request_-&gt;url.has_username() &amp;&amp;        auth_identity_[target].source == HttpAuth::IDENT_SRC_NONE) {      auth_identity_[target].source = HttpAuth::IDENT_SRC_URL;      auth_identity_[target].invalid = false;      // Extract the username:password from the URL.      GetIdentifyFromUrl(request_-&gt;url                          &amp;auth_identity_[target].username                          &amp;auth_identity_[target].password);      // TODO(eroman): If the password is blank  should we also try combining      // with a password from the cache?      return true;    }    This code assumes that HttpAuth::IDENT_SRC_NONE is the initial  value of auth_identity_[target].source  and that once  auth_identity_[target].source is set to some other value   it'll never be changed back to HttpAuth::IDENT_SRC_NONE.    The first assumption is correct.  The second assumption is  correct for the Basic and Digest schemes  but is wrong for  the NTLM scheme.  For NTLM  if the embedded username/password  is wrong  we will execute the &quot;else&quot; part in the code below   which changes auth_identity_[target].source back to  HttpAuth::IDENT_SRC_NONE:      if (auth_handler_[target]-&gt;NeedsIdentity()) {      // Pick a new auth identity to try  by looking to the URL and auth   cache.      // If an identity to try is found  it is saved to   auth_identity_[target].      SelectNextAuthIdentityToTry(target);    } else {      // Proceed with a null identity.      //      // TODO(wtc): Add a safeguard against infinite transaction restarts  if      // the server keeps returning &quot;NTLM&quot;.      auth_identity_[target].source = HttpAuth::IDENT_SRC_NONE;      auth_identity_[target].invalid = false;      auth_identity_[target].username.clear();      auth_identity_[target].password.clear();    }    This will cause us to use the embedded (incorrect) username/password  again  resulting in an infinite loop of failure and retry.    For Basic and Digest  NeedsIdentity() always returns true  so  the second assumption is true.    I propose that we add a bool &quot;embedded_identity_used_&quot; member to  fix this bug. </pre>
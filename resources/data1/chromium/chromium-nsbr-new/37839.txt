<title>Issue 37839 -   chromium -    A data race on a ConditionVariable (!) and a typo in chrome/browser/sync/util_event_sys_unittest - Project Hosting on Google Code</title> <pre> Hi     First of all  data race:  It was detected manually after seeing a couple of strange reports by ThreadSanitizer  (see <a href="http://www.chromium.org/developers/how-tos/using-valgrind/threadsanitizer">http://www.chromium.org/developers/how-tos/using-valgrind/threadsanitizer</a> ).    After some investigation I found a real race happening on a ConditionVariable allocated on stack in ThreadTester::Go().    What happens there:    // Thread1  244 TEST(EventSys  Multithreaded) {  245   Pair sally(&quot;Sally&quot;);  246   ThreadTester a(&amp;sally);  247   for (int i = 0; i &lt; 3; ++i)  248     a.Go();  249   sally.set_b(99);  250 }  ...  177   void Go() {  178     Lock thread_running_mutex;  179     ConditionVariable thread_running_cond(&amp;thread_running_mutex);  ...  188     ASSERT_TRUE(PlatformThread::Create(0  this  &amp;info.thread));  // Thread2-3-4 start  189     thread_running_mutex.Acquire();  190     while ((args_.thread_running) == false) {  191       thread_running_cond.Wait();  192     }  193     thread_running_mutex.Release();  194     threads_.push_back(info);  // Lock and ConditionVariable are destroyed when leaving this function!!!  195   }      // Thread2  198   virtual void ThreadMain() {  199     // Make sure each thread gets a current MessageLoop in TLS.  200     // This test should use chrome threads for testing  but I'll leave it like  201     // this for the moment since it requires a big chunk of rewriting and I  202     // want the test passing while I checkpoint my CL.  Technically speaking   203     // there should be no functional difference.  204     MessageLoop message_loop;  205     args_.thread_running_mutex-&gt;Acquire();  206     args_.thread_running = true;  207     args_.thread_running_mutex-&gt;Release();  // ConditionVariable can already be destroyed!  208     args_.thread_running_cond-&gt;Signal();  ...    See <a href="http://codereview.chromium.org/782003">http://codereview.chromium.org/782003</a> for the patch that adds a couple of CHECKs to ConditionVariable  and exhibits a specific thread scheduling using Sleep().    This is a pretty nasty example of &quot;DON'T call pthread_cond_signal outside a lock&quot;...    =================================    Second  a typo:  struct ThreadInfo {    PlatformThreadHandle thread;    bool* completed;  };    You've probably intended &quot;bool completed&quot; since you use it like an ordinary bool  not a pointer.  I'm surprised the compiler didn't issue any warnings... </pre>
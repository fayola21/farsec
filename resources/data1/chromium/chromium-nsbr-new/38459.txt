<title>Issue 38459 -   chromium -    The plugin channel may be closed prematurely.  LOG(ERROR) &lt;&lt; &quot;Refusing use of missing IPC channel &quot; &lt;&lt; channel_name() - Project Hosting on Google Code</title> <pre> Following up from <a title="Crash in IPC::Channel::ChannelImpl::CreatePipe(std::string const&amp;  IPC::Channel::Mode) calling DebugUtil::BreakDebugger(..." class=closed_ref href="/p/chromium/issues/detail?id=26754"> bug 26754 </a>  which at least made this problem non-fatal.    It looks like the plugin channel is being closed prematurely.  When this happens and the renderer   is unable to recover  we will now log this message:    [65270:519:19462069568972:ERROR:/chrome/trunk/src/chrome/renderer/plugin_channel_host.  cc(98)] Refusing use of missing IPC channel 65285.<a href="/p/chromium/source/detail?r=11">r11</a>    Earlier on in the program  the renderer will have attempted to send a HELLO message and a   PluginMsg_CreateInstance message to the plugin process over this very IPC channel  and   succeeded.  It will then have attempted to receive a message from this IPC channel and failed on   an EOF condition.  This EOF is spurious.    If the renderer-side file descriptor for the plugin channel is not marked as auto-close in the   plugin process  this condition is never encountered.    chrome/plugin/plugin_thread.cc:148 PluginThread::OnCreateChannel(int  bool):      channel_handle.socket = base::FileDescriptor(renderer_fd  true);    By changing |true| to |false|  the renderer-side file descriptor is not marked as auto-close.  This   isn't a solution  because it means that the FD will be leaked.    channel_handle in this case is passed from the plugin process to the plugin process host in the   browser process  which in turn passes it to the renderer process.  The plugin process shouldn't be   auto-closing this FD until it's already been sent to another process.  There may be an OS-specific   (meaning kernel) bug at play here.  I haven't read how we auto-close recently  but I seem to recall   that it was pretty robust. </pre>
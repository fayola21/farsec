<title>Issue 29240 -   chromium -    Should not use dynamic memory in signal handlers - Project Hosting on Google Code</title> <pre> I noticed that we were doing this when I tried to switch Linux to using tcmalloc.    Here's the example that I saw:    ===    void GracefulShutdownHandler(int signal  const int expected_signal) {    DCHECK_EQ(signal  expected_signal);    LOG(WARNING) &lt;&lt; &quot;Addressing signal &quot; &lt;&lt; expected_signal &lt;&lt; &quot; on &quot;                 &lt;&lt; PlatformThread::CurrentId();      bool posted = ChromeThread::PostTask(        ChromeThread::UI  FROM_HERE         NewRunnableFunction(BrowserList::CloseAllBrowsersAndExit));      // Reinstall the default handler.  We had one shot at graceful shutdown.    struct sigaction action;    memset(&amp;action  0  sizeof(action));    action.sa_handler = SIG_DFL;    CHECK(sigaction(expected_signal  &amp;action  NULL) == 0);      if (posted) {      LOG(WARNING) &lt;&lt; &quot;Posted task to UI thread; resetting signal &quot;                   &lt;&lt; expected_signal &lt;&lt; &quot; handler&quot;;    } else {      // Without a UI thread to post the exit task to  there aren't many      // options.  Raise the signal again.  The default handler will pick it up      // and cause an ungraceful exit.      LOG(WARNING) &lt;&lt; &quot;No UI thread  exiting ungracefully&quot;;      kill(getpid()  signal);        // The signal may be handled on another thread.  Give that a chance to      // happen.      sleep(3);        // We really should be dead by now.  For whatever reason  we're not. Exit      // immediately  with the exit status set to the signal number with bit 8      // set.  On the systems that we care about  this exit status is what is      // normally used to indicate an exit by this signal's default handler.      // This mechanism isn't a de jure standard  but even in the worst case  it      // should at least result in an immediate exit.      LOG(WARNING) &lt;&lt; &quot;Still here  exiting really ungracefully&quot;;      _exit(signal | (1 &lt;&lt; 7));    }  }    ===    This causes problems because a malloc() implementation may have acquired locks   before entering the signal handler  so re-entering malloc() can potentially cause   deadlocks.  See the stacktrace posted in <a title="modules linux startup test is flaky" class=closed_ref href="/p/chromium/issues/detail?id=28828"> issue 28828 </a> for an example.    Off the top of my head  all the LOG/CHECK calls use dynamic memory  and so does   NewRunnableFunction() and probably PostTask().    I suspect the solution is to use a global bool which a task running on the UI   thread can always check each time it goes through the message loop.    It looks like this code originated in <a href="http://codereview.chromium.org/255036/show">http://codereview.chromium.org/255036/show</a>    so I'm adding people from that changelist to comment on a solution. </pre>
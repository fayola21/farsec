<title>Issue 42327 -   chromium -    Centralize TLS teardown and add defensive coding to TCMalloc - Project Hosting on Google Code</title> <pre> A recent bug (#40663) revealed that TLS (Thread Local Store) teardown was   not notifying users of TLS (on Windows) of the thread termination.  In   addition  it made it clear that several users were making use of the   teardown facility.  As noted in that bug  this class of problem can cause a   very large memory leak.    TCMalloc teardown should (if possible) be called last during teardown   sequence for a thread  so that any allocations and frees performed by other   teardown tasks (on the departing thread) don't do allocations (which might   use tcmalloc) after tcmalloc-teardown.  To support &quot;running last&quot; the   teardown infrastructure should be centralized  so that participants can be   explicit about their order in the teardown cycle.  This should probably be   set up so that support is transparently cross platform.  I was told that   pthread (non-Windows) supports repeated calls to any remaining teardown   requests  but getting a sequenced shutdown may be preferable (I'm not   sure).    As defensive code in TCMalloc  each thread cache should have a clear   lifecycle consisting of a) uninitialized; b) initialized and running; c)   post-teardown.   When a thread is in the post-teardown state  it should   probably DCHECK if there is an attempt to allocate/free.  For more   defensive coding  it should avoid growing or using TLS controlled storage   in the post-teardown state  and should probably do slow but valid   allocations from the central heap (i.e.  for an alloc  request ONLY the   allocation needed  and not fill its TLS cache; for a free  it should   immediately push the free block to centralized class storage).    Finally  to more quickly identify any failure to teardown TCMalloc  there   should be a process termination CHECK that validates that all (most?)   threads that were set up with a TCMalloc cache  were also torn down.  This   will warn us if an optimizer (or coding error) leads to a failure to   properly teardown on a thread.    As a related visualization  the about:memory page should indicate the   number of TCMalloc thread-caches that are currently active  and that should   help to diagnose any sort of leak of these caches (due to insufficient   teardowns). </pre>
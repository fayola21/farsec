<title>Issue 43258 -   chromium -    Deal with glUniform1f and bool uniforms - Project Hosting on Google Code</title> <pre> I ran into this issue today  testing uniforms  that apparently setting a   bool uniform with glUniform1f generates an error even though the specs all   say it should succeed.    From the OpenGL ES 2.0 spec  section 2.10.4    When loading values for a uniform declared as a boolean  a boolean vector   an array of booleans  or an array of boolean vectors  both the Uniform*i{v}   and  Uniform*f{v} set of commands can be used to load boolean values. Type   conver-  sion is done by the GL. The uniform is set to FALSE if the input value is 0   or 0.0f   and set to TRUE otherwise.    The OpenGL 2.1  3.3 and 4.0 spec all have the same language.     Here's my test code in C++. Maybe there is an error?       const char* vsrc =         &quot;attribute vec4 pos;n&quot;         &quot;void main (void) {n&quot;         &quot;  gl_Position = pos;n&quot;         &quot;}n&quot;;     const char* fsrc =         &quot;uniform bool color;n&quot;         &quot;void main (void) {n&quot;         &quot;  gl_FragColor = vec4(float(color)  0.0  0.0  1.0);n&quot;         &quot;}n&quot;;     GLuint vs = glCreateShader(GL_VERTEX_SHADER);     GLuint fs = glCreateShader(GL_FRAGMENT_SHADER);     GLuint prg = glCreateProgram();     glShaderSource(vs  1  &amp;vsrc  NULL);     glShaderSource(fs  1  &amp;fsrc  NULL);     glCompileShader(vs);     glCompileShader(fs);     glAttachShader(prg  vs);     glAttachShader(prg  fs);     glLinkProgram(prg);     GLint success;     glGetProgramiv(prg  GL_LINK_STATUS  &amp;success);     printf(&quot;Link: %sn&quot;  success ? &quot;good&quot; : &quot;*BAD*&quot;);       GLint bloc = glGetUniformLocation(prg  &quot;color&quot;);     printf(&quot;Loc : %dn&quot;  bloc);         printf(&quot;err : %04xn&quot;  glGetError());     glUniform1f(bloc  0.0f);     printf(&quot;err : %04xn&quot;  glGetError());    The output of the above program is    Link: good  Loc : 0  err : 0000  err : 0502    As far as I can tell that error is incorrect. Yet I've tried this on   Windows7 with an NVidia Quadro FX 380  A Macbook Pro with GeForce 8600M GT   and another Macbook Pro with some ATI Radeon X1600.    If my C code above is bad then color me embarrassed but please point out   what I'm missing. Otherwise this is important because if the code above is   correct  then the WebGL spec currently requires that the same code in WebGL   not get an error and so implementations have to do more work to work around   the apparent bug all these drivers.   </pre>
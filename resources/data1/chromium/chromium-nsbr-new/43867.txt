<title>Issue 43867 -   chromium -    Bug in the Windows sandbox function AutoProtectMemory::RevertProtection() [sandbox_nt_util.cc] may result in page protections being restored incorrectly  resulting in a crash - Project Hosting on Google Code</title> <pre> Chrome Version       : 4.1.249.1064    The function AutoProtectMemory::ChangeProtection()  [/src/sandbox/src/sandbox_nt_util.cc] uses NtProtectVirtualMemory() to  change page protections and uses RAII to revert the page protection back to  the original value (via AutoProtectMemory::RevertProtection()).    ChangeProtection()  however  records the private address_ and bytes_ values  in an inconsistent manner:    SIZE_T new_bytes = bytes;    NTSTATUS ret = g_nt.ProtectVirtualMemory(NtCurrentProcess  &amp;address                                              &amp;new_bytes  protect  &amp;old_protect_);    if (NT_SUCCESS(ret)) {      changed_ = true;      address_ = address;  	bytes_ = bytes;    }    It stores the *new* address that NtProtectVirtualMemory returned (this is  page aligned  and &lt;= the original address passed in) but stores the *old*  bytes value (and not the new_bytes returned).     Imagine what happen if  say  a 32-byte region's protection were being  changed (by the SidestepResolverThunk::Setup() to PAGE_READWRITE) and that  region straddled two pages  A and B. NtProtectVirtualMemory() would  actually change the protection of the two pages  return the starting of  page A in &quot;address&quot; and set &quot;new_bytes&quot; to 2*PAGE_SIZE. But now  ChangeProtection will record &quot;address_&quot; to the start of the page A but set  &quot;bytes_&quot; as the original value  32. So at the time of RevertProtection()   only one page A's protection will be reverted  leaving page B with the  wrong protection (PAGE_READWRITE rather than the original PAGE_EXECUTE_READ).    The implication is that as soon as any instruction lying in the  &quot;unreverted-protection&quot; page (page B above) is executed  an access  violation would be triggered.    The chances of SidestepResolverThunk  that I've seen uses ~32-byte thunks   hitting this bug are greater than EatResolverThunk  that uses sizeof(DWORD)  = 4 bytes. Even then the bug would occur only rarely because the small  region would have to lie right at the boundary of the page etc.    Changing &quot;bytes_ = bytes;&quot; to &quot;bytes_ = new_bytes;&quot; above should fix the  problem.   </pre>
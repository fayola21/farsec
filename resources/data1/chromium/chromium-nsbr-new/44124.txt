<title>Issue 44124 -   chromium -    Avoid unnecessary memory copying in scrolling case - Project Hosting on Google Code</title> <pre> Chrome Version (from the about:version page): 45042  Is this the most recent version: Yes  OS + version: Chromium OS  ubuntu  CPU architecture (32-bit / 64-bit): 32-bit            Note: First time contributor  please feel free the comment on the procedures  reviewers    etc.    Attached a xtrace log file for X interactions between browser and X server    Read the line 90212 to 90257. It gives the X transactions when pressing a down key    Each renderer thread maintain a backstore  and the way it works is that renderer   thread(process) will update its backing_store first when scroll happens. And then this   backing store will be copied to the browser/render_host window to be displayed.    From the trace you will see the following copies:    1. (XCopyArea) backing store copies into itself  but 40 lines shift. It is backstore self   scrolling.    2. (XShmPutImage) Browser copy a full screen size rect into a XImage.    3. (XRender) Render the scrollbar of 15 vertical lines form 2) into Backing Store    4. (XRender) Render the damaged 40 lines of scrolling rect from 2) into Backing store    5. (XCopyArea) the full screen of back store into main browser main window to be   displayed.    6. (XCopyArea) the scrollbar of 15 vertical lines into main browser window    7. (XCopyArea) the 40 horizontal lines of scrolling part into main browser window.    From a new comer's perspective  it is doesn't quite make sense at least in step 2. Why we   copied the whole rect  but only used(rendered) scrollbar and 40 lines of scrolling?        chrome/browser/renderer_host/render_widget_host.cc#718  This is the code for step 1. If it is a scroll  backing store will scroll itself for 40   lines.    chrome/browser/renderer_host/backing_store_x.cc#147  This is function that is responsible for step 2 3 4. You will see that in the case of we   don't have shared memory pixmap  we will copy the whole &quot;image&quot; from arguments into   XImage  and render the &quot;copy_rects&quot; from arguments into backing store...  chrome/browser/renderer_host/backing_store_x.cc#197      DoDeferredUpdate function is the one that sends render_host the parameter to paint to   backing store. chrome/renderer/render_widget.cc#432. As you will see  here it sends the   UNION of all damaged area as &quot;image&quot; to copy and putting all damage rects into copy_rects   list. This explain  why we have the extra copy in step 2 that we copy the whole screen   image  but only RENDER the 40 lines and scrollbar. It is because the whole screen is the   UNION of these two damaged area.        Now comes the section of patches to fix the problem. I will submit the patch with gcl.    1) The current fix is to mark a variable of &quot;is_scroll&quot; to show that we are in scrolling.   And then in step 2  we only XShmPutImage the damaged &quot;copy_rects&quot;. By this way  we save   the copy of &quot;a full screen sides minus 40 lines  and minus scrollbar&quot;.      2) Here are other ways we had tried:  a) Are in all cases that &quot;copy_rects&quot; are the only valid parts to render? Then why not   always ONLY XShmPutImage the damanged &quot;copy_rects&quot;  removing the is_scroll mode? It turns   out not works for me  not scrolling correctly...    b) Why do we have to always copy the damaged area into X server using XShmPutImage  and   then XRender into backing store? Is this a wasting extra copy? Why can't we directly copy   damaged area into backing store? It turns out reporting X crash...      Failure (a) shows that the whole screen copy in step 2 sometime is needed... Need more   understanding of failure (b) about the X protocol.    To sum up  there is more unknowns than knowns in this problem. It will be great if   someone can share some lights on the theory behind this whole thing  and give right   directions to fix this (if it indeed is a problem).    Thanks   -Xin Qi       </pre>
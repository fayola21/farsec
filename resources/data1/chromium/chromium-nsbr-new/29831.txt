<title>Issue 29831 -   chromium -    Refactor ModelAssociator for reusability with other data types - Project Hosting on Google Code</title> <pre> The ModelAssociator is bookmark specific at this time but we will want at   least a part of the functionality it provides for other data types.  We may   not need to perform cross-model ID persisting for all types (a url may   uniquely identify an extension in the Chrome model  for example)  but the   concept of reconciling differences between the browser model and the sync   model on startup (and detecting such a difference in the first place) is   something we want.    A possible common interface might look something like    template &lt;class ChromeModelEntity  class ChromeIDType&gt;  class ModelAssociator {   public:    virtual bool AssociateModels() = 0;    virtual void GetSyncIdFromChromeID(ChromeIDType id) = 0;    virtual ChromeModelEntity* GetChromeObjectFromSyncId(int64 id) = 0;    virtual bool InitSyncNodeFromChromeID(ChromeIDType    syncapi::BaseNode*) = 0;    virtual void Associate(ChromeModelEntity* t  int64 sync_id) = 0;    virtual void Dissociate(int64 sync_id) = 0;  }    class BookmarkModelAssociator : public ModelAssociator&lt;BookmarkNode    int64&gt;  class PasswordModelAssociator : public ModelAssociator&lt;PasswordForm    string&gt; ...    One of the meta fields in the sync DB is the &quot;external ID&quot; which for   bookmarks is the bookmark node id() value  but this could be made   optional for some data types. </pre>
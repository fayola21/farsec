<title>Issue 44168 -   chromium -    Benign race on vfptr in libjingle - Project Hosting on Google Code</title> <pre> <a href="http://build.chromium.org/buildbot/waterfall.fyi/builders/Linux%20Tests%20(tsan%20x64)/builds/4395/steps/valgrind%20test:%20sync/logs/stdio">http://build.chromium.org/buildbot/waterfall.fyi/builders/Linux%20Tests%20(tsan%20x64)/builds/4395/steps/valgrind%20test:%20sync/logs/stdio</a>  WARNING: Possible data race during write of size 8 at 0x483DE78: {{{     T0 (locks held: {}):      #0  notifier::MediatorThreadImpl::~MediatorThreadImpl() chrome/common/net/notifier/listener/mediator_thread_impl.cc:28      #1  scoped_ptr&lt;notifier::MediatorThread&gt;::~scoped_ptr() base/scoped_ptr.h:74      #2  notifier::TalkMediatorImpl::~TalkMediatorImpl() chrome/common/net/notifier/listener/talk_mediator_impl.cc:79      #3  scoped_ptr&lt;notifier::TalkMediator&gt;::~scoped_ptr() base/scoped_ptr.h:74      #4  browser_sync::AuthWatcherTest::~AuthWatcherTest() chrome/browser/sync/engine/auth_watcher_unittest.cc:88      #5  browser_sync::AuthWatcherTest_AuthenticateWithTokenSuccess_Test::~AuthWatcherTest_AuthenticateWithTokenSuccess_Test() chrome/browser/sync/engine/auth_watcher_unittest.cc:219      #6  testing::internal::TestInfoImpl::Run() testing/gtest/src/gtest.cc:2319    Concurrent read(s) happened at (OR AFTER) these points:     T40 (locks held: {L918}):      #0  talk_base::SignalThread::Run() third_party/libjingle/files/talk/base/signalthread.cc:125      #1  talk_base::SignalThread::Worker::Run() third_party/libjingle/files/talk/base/signalthread.h:82      #2  talk_base::Thread::PreRun(void*) third_party/libjingle/files/talk/base/thread.cc:220      #3  ThreadSanitizerStartThread ts_valgrind_intercepts.c:571    Location 0x483DE78 is 120 bytes inside a block starting at 0x483DE00 of size 464 allocated by T0 from heap:      #0  operator new(unsigned long) ts_valgrind_intercepts.c:407      #1  notifier::TalkMediatorImpl::TalkMediatorImpl(bool) chrome/common/net/notifier/listener/talk_mediator_impl.cc:44      #2  browser_sync::AuthWatcherTest::SetUp() chrome/browser/sync/engine/auth_watcher_unittest.cc:106      #3  testing::Test::Run() testing/gtest/src/gtest.cc:2090    Locks involved in this report (reporting last lock sites): {L918}     L918      #0  pthread_mutex_lock ts_valgrind_intercepts.c:818      #1  talk_base::CriticalSection::Enter() third_party/libjingle/files/talk/base/criticalsection.h:96      #2  talk_base::SignalThread::EnterExit::EnterExit(talk_base::SignalThread*) third_party/libjingle/files/talk/base/signalthread.h:91      #3  talk_base::SignalThread::Run() third_party/libjingle/files/talk/base/signalthread.cc:123      #4  talk_base::SignalThread::Worker::Run() third_party/libjingle/files/talk/base/signalthread.h:82      #5  talk_base::Thread::PreRun(void*) third_party/libjingle/files/talk/base/thread.cc:220      #6  ThreadSanitizerStartThread ts_valgrind_intercepts.c:571  }}}    Looks like this is <a href="http://code.google.com/p/data-race-test/wiki/PopularDataRaces#Data_race_on_vptr">http://code.google.com/p/data-race-test/wiki/PopularDataRaces#Data_race_on_vptr</a>    If I understood the code correctly  MediatorThreadImpl is deleted in TalkMediatorThread only  after calling Logout()/Stop() in TalkMediatorThread::Logout().  If this is true  then the data race is benign.  If there are any codepaths when MediatorThreadImpl can be deleted WITHOUT calling Stop()  the data race is real and may be harmful.    Nick  Tim  is it possible to explicitly call Stop() in MediatorThreadImpl() destructor to avoid possible mistakes in the future?  As you probably know  in base/thread.h there is a comment saying  &quot;If you are subclassing from Thread  and you wish for your CleanUp  method to be called  then you need to call Stop() from your destructor.&quot; - this is done exactly to avoid the vptr races. </pre>
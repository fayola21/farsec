<title>Issue 26392 -   chromium -    Investigate impact of sqlite application-defined page cache - Project Hosting on Google Code</title> <pre> sqlite implements per-connection page caches atop a (process-)global page   cache  which is effectively a reimplementation of virtual memory.    Presumably  this is useful for systems without VM  or with terrible malloc   implementations; for us it's probably no win.    There are a couple potential negative consequences of the current system:    * Because the page cache is protected with mutexes  and we use sqlite on   several threads  we could perhaps have lock contention issues  especially   if we ever have to page something in while under the lock (I hope not).    This effect may worsen in the future  especially in the renderer  as   features like local storage and databases get turned on.    * Because we open a file and read its data into a page we malloc  we may   populate these pages more slowly than if we mmap()ed the file directly.    (OTOH  if we blindly mmap() all DBs  we may contribute to virtual address   space exhaustion).    * Conceivably  the way these pages are alloced and released could be worse   than the algorithms tcmalloc or the OS would use if we just used those   directly.    There is probably a way to plug in our own page cache (see   <a href="http://www.sqlite.org/c3ref/pcache_methods.html">http://www.sqlite.org/c3ref/pcache_methods.html</a> ) that does things like   backs each connection with its own pool of memory or mmap()s files in   directly.  It's not clear how much this would help.    One consequence of doing this is that we would lose the ability to call   sqlite3_release_memory().  Presumably  we could define our own similar   hooks.    There are other memory-related issues in sqlite that aren't due to the   application-defined page cache  but I will mention for completeness:    * For locality or stability reasons we might want to replace the allocator   with something that does an arena allocation for all sqlite memory.    * sqlite attaches metadata to each page in the cache  making it an odd   size  which probably has negative cache line effects.  With major surgery   to sqlite it might be possible to store this data separately (or in some   cases not at all)  which might buy us something. </pre>
<title>Issue 34597 -   chromium -    ffmpeg out-of-bounds read - Project Hosting on Google Code</title> <pre> The &quot;lzw_get_code&quot; function can read beyond the end of the buffer containing LZW compressed data:    third_partyffmpegsourcepatched-ffmpeg-mtlibavcodeclzw.c:    /* get one code from stream */  static int lzw_get_code(struct LZWState * s)  {      int c;        if(s-&gt;mode == FF_LZW_GIF) {          while (s-&gt;bbits &lt; s-&gt;cursize) {              if (!s-&gt;bs) {                  s-&gt;bs = *s-&gt;pbuf++;                   // *** KaB00M: No check if we're past the end of pbuf              }              s-&gt;bbuf |= (*s-&gt;pbuf++) &lt;&lt; s-&gt;bbits;      // *** KaB00M: No check if we're past the end of pbuf              s-&gt;bbits += 8;              s-&gt;bs--;          }          c = s-&gt;bbuf;          s-&gt;bbuf &gt;&gt;= s-&gt;cursize;      } else { // TIFF          while (s-&gt;bbits &lt; s-&gt;cursize) {              s-&gt;bbuf = (s-&gt;bbuf &lt;&lt; 8) | (*s-&gt;pbuf++);  // *** KaB00M: No check if we're past the end of pbuf              s-&gt;bbits += 8;          }          c = s-&gt;bbuf &gt;&gt; (s-&gt;bbits - s-&gt;cursize);      }      s-&gt;bbits -= s-&gt;cursize;      return c &amp; s-&gt;curmask;  }    A maliciously constructed GIF or TIFF file that ends the image data either in the middle of the bits of an LZW code or immediately after a GIF block size byte will cause the   code to read beyond the image data. The attribute &quot;ebuf&quot; contains the end of the buffer and should be used to prevent this.    Also  GIF end block terminator (block with size 0) is not handled by this code  causing it to continue to read data beyond the block terminator.    Both issues can cause a read access violation  so there is no immediate security impact.    Found while reviewing the code  so no repro case available at this moment.    Should probably be filed upstream? </pre>
<title>Issue 26402 -   chromium -    Possible autorelease delays - Project Hosting on Google Code</title> <pre> I was theorizing about this a few hours ago and took these notes for   myself.    It may be moot given <a title="Our thing is broken on Snow Leopard" class=closed_ref href="/p/chromium/issues/detail?id=26399"> bug 26399 </a> but I want to get it down here so we don't   lose it.    (Actually I found all of the badness in <a title="Our thing is broken on Snow Leopard" class=closed_ref href="/p/chromium/issues/detail?id=26399"> bug 26399 </a> when I sat down at a   Snow Leopard box to test the following out.)    --    Uh-oh  I thought of a way to break this.    1. Outer loop calls RunWork.  2. RunWork does something that autoreleases stuff.  Stuff winds up in the   deferred autorelease pool.  3. When RunWork returns  it sets needs_event_loop_wake_up_ true.  4. Outer loop calls RunDelayedWork.  5. Inside RunDelayedWork  something pumps the NSApp loop.  6. When the NSApp loop runs the CFRunLoop  this EnterExitRunLoop code   runs  finds needs_event_loop_wake_up_ is true  posts the fake event  and   sets needs_event_loop_wake_up_ false.  7. I think you see where I'm going with this.  8. The inner loop stops.  9. Return to RunDelayedWork without anything having been autoreleased   to its deferred pool.  10. Return from RunDelayedWork and come out of the CFRunLoop  ending   up here again in this EnterExitRunLoop.  11. needs_event_loop_wake_up_ is false.  No fake event gets posted.  12. Go to sleep without releasing the stuff autoreleased in step 2.    Intuitively  it would be nice to fix this by tracking the previous state of   needs_event_loop_wake_up_ on the stack.  Unfortunately  we don't have   anything that stays on the stack long enough to handle this.  All we've got   is EnterExitRunLoop  which we need to return from.    We ought to be able to fix this with nesting_level_.    Turn needs_event_loop_wake_up_ from a bool into a std::vector&lt;bool&gt;.    Each element corresponds to a nesting_level_.    In EnterExitRunLoop with activity kCFRunLoopEnter  do   needs_event_loop_wake_up_.push_back(false).  With activity   kCFRunLoopExit  check needs_event_loop_wake_up_.back() as the   condition for calling WakeUpEventLoop  and call   needs_event_loop_wake_up_.pop().  set_needs_event_loop_wake_up_true   needs to change to set needs_event_loop_wake_up_[nesting_level()] to true.    DCHECK the vector size when operating on it.    The nesting levels need to be realigned in EnterExitObserver so that   EnterExitRunLoop is called with a consistent nesting_level() available when   entering and exiting the same loop.  There's another subclass using   nesting_level in EnterExitRunLoop  it needs to be adjusted for this change.    The MessagePumpNSApplication constructor would need to initialize   needs_event_loop_wake_up_ with one element at index 0 so that the first   push_back would be at index 1 corresponding to nesting level 1. </pre>
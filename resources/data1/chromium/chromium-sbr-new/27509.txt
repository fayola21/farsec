<title>Issue 27509 -   chromium -    Security: HttpStreamParser::DoReadBodyComplete buffer overflow. - Project Hosting on Google Code</title> <pre> Placeholder for a bug found with HTTP fuzzer that crashes the browser (not just the renderer). I am trying  to find out what triggers it  but considering this is memory corruption  it's kinda hard to find out.    Attached are:  - a &quot;repro pickle&quot;: a pickle file containing HTTP replies that trigger the issue in Chrome.  - &quot;repro server&quot;: a lightweight HTTP server written in python that can be used to serve the repro to Chrome.    Here is one of the stacks I have seen in a crash (my framework has documented 59 unique call stacks so far   but given this is memory corruption  there could be any number of them):    tcmalloc::ThreadCache::Allocate(unsigned int size = 0x80)+0x76  `anonymous namespace'::do_malloc(unsigned int size = 0x80)+0xb3  malloc(unsigned int size = 0x80)+0x32  generic_cpp_alloc(unsigned int size = 0x80  bool nothrow = false)+0xc  operator new(unsigned int size = 0x80)+0xe  std::_Allocate&lt;char&gt;(unsigned int _Count = 0x80  char * __formal = 0x00000000 &quot;&quot;)+0x67  std::basic_string&lt;char std::char_traits&lt;char&gt; std::allocator&lt;char&gt; &gt;::_Copy(unsigned int _Newsize = 0x7b  unsigned int _Oldlen = 0x4d)+0x46  std::basic_string&lt;char std::char_traits&lt;char&gt; std::allocator&lt;char&gt; &gt;::replace(unsigned int _Off = 0x7b  unsigned int _N0 = 0  char * _Ptr = 0x05fcf84d &quot;Accept-Charset: ISO-8859-1 utf-8;q=0.7 *;q=0.3..&quot;  unsigned int _Count = 0x2e)+0x122  std::basic_string&lt;char std::char_traits&lt;char&gt; std::allocator&lt;char&gt; &gt;::replace(class std::_String_iterator&lt;char std::char_traits&lt;char&gt; std::allocator&lt;char&gt; &gt; _First = class std::_String_iterator&lt;char std::char_traits&lt;char&gt; std::allocator&lt;char&gt; &gt;  class std::_String_iterator&lt;char std::char_traits&lt;char&gt; std::allocator&lt;char&gt; &gt; _Last = class std::_String_iterator&lt;char std::char_traits&lt;char&gt; std::allocator&lt;char&gt; &gt;  class std::_String_const_iterator&lt;char std::char_traits&lt;char&gt; std::allocator&lt;char&gt; &gt; _First2 = class std::_String_const_iterator&lt;char std::char_traits&lt;char&gt; std::allocator&lt;char&gt; &gt;  class std::_String_const_iterator&lt;char std::char_traits&lt;char&gt; std::allocator&lt;char&gt; &gt; _Last2 = class std::_String_const_iterator&lt;char std::char_traits&lt;char&gt; std::allocator&lt;char&gt; &gt;)+0x16c  std::basic_string&lt;char std::char_traits&lt;char&gt; std::allocator&lt;char&gt; &gt;::append(class std::_String_const_iterator&lt;char std::char_traits&lt;char&gt; std::allocator&lt;char&gt; &gt; _First = class std::_String_const_iterator&lt;char std::char_traits&lt;char&gt; std::allocator&lt;char&gt; &gt;  class std::_String_const_iterator&lt;char std::char_traits&lt;char&gt; std::allocator&lt;char&gt; &gt; _Last = class std::_String_const_iterator&lt;char std::char_traits&lt;char&gt; std::allocator&lt;char&gt; &gt;)+0x66  net::HttpCache::Transaction::SetRequest(class net::LoadLog * load_log = 0x05f9fd60  class net::HttpRequestInfo * request = 0x00d1abe4)+0x1cc  net::HttpCache::Transaction::Start(class net::HttpRequestInfo * request = 0x00d1abe4  class CallbackRunner&lt;Tuple1&lt;int&gt; &gt; * callback = 0x00d1ad20  class net::LoadLog * load_log = 0x05f9fd60)+0x127  URLRequestHttpJob::StartTransaction(void)+0x15e  URLRequestHttpJob::Start(void)+0x140  URLRequest::StartJob(class URLRequestJob * job = 0x00d1ab00)+0x175  URLRequest::Start(void)+0x18  ResourceDispatcherHost::BeginRequestInternal(class URLRequest * request = 0x06379240)+0x1a6  ResourceDispatcherHost::BeginRequest(int request_id = 36  struct ViewHostMsg_Resource_Request * request_data = 0x0146f868  class IPC::Message * sync_result = 0x00000000  int route_id = 1)+0x9c0  ResourceDispatcherHost::OnRequestResource(class IPC::Message * message = 0x0146fc54  int request_id = 36  struct ViewHostMsg_Resource_Request * request_data = 0x0146f868)+0x23  IPC::MessageWithTuple&lt;Tuple2&lt;int ViewHostMsg_Resource_Request&gt; &gt;::Dispatch&lt;ResourceDispatcherHost int ViewHostMsg_Resource_Request const &amp;&gt;(class IPC::Message * msg = 0x0146fc54  class ResourceDispatcherHost * obj = 0x00c45680  &lt;function&gt; * func = 0x01c61710)+0x51  ResourceDispatcherHost::OnMessageReceived(class IPC::Message * message = 0x0146fc54  class ResourceDispatcherHost::Receiver * receiver = 0x00c980f8  bool * message_was_ok = 0x0146faef)+0x5d  ResourceMessageFilter::OnMessageReceived(class IPC::Message * msg = 0x0146fc54)+0x3c  IPC::ChannelProxy::Context::TryFilters(class IPC::Message * message = 0x0146fc54)+0x46  IPC::SyncChannel::SyncContext::OnMessageReceived(class IPC::Message * msg = 0x0146fc54)+0x10  IPC::Channel::ChannelImpl::ProcessIncomingMessages(struct base::MessagePumpForIO::IOContext * context = 0x04e510fc  unsigned long bytes_read = 0xa4)+0x2eb  IPC::Channel::ChannelImpl::OnIOCompleted(struct base::MessagePumpForIO::IOContext * context = 0x04e51004  unsigned long bytes_transfered = 0xa4  unsigned long error = 0)+0xb2  base::MessagePumpForIO::WaitForIOCompletion(unsigned long timeout = 0  class base::MessagePumpForIO::IOHandler * filter = 0x00000000)+0xf1  base::MessagePumpForIO::DoRunLoop(void)+0x2b  base::MessagePumpWin::Run(class base::MessagePump::Delegate * delegate = 0x0146fef0)+0x40  MessageLoop::RunInternal(void)+0xc0  MessageLoop::Run(void)+0x57  base::Thread::Run(class MessageLoop * message_loop = 0x0146fef0)+0xb  base::Thread::ThreadMain(void)+0x8c  `anonymous namespace'::ThreadFunc(void * closure = 0x00ca8a40)+0xd    I will try to manually reduce the size of the repro a bit further: my framework is finding  this hard to do automagically as the repro does not always crash the browser and causes  any number of different crashes when it does. I'll also try to track down the cause. </pre>
<title>Issue 31009 -   chromium -    [MD audit] [V8]: integer errors lead to dangerous crashes in memory allocators - Project Hosting on Google Code</title> <pre> Quoting Mark's raw report below.    My notes:  - Definitely SecSeverity-High. If possible  we should sneak a fix into v4.  - I'm surprised this triggers on my x86_64 Linux build. The root cause of   the integer overflow needs fixing of course -- but if e.g. size_t (64-bit   on x86_64) had been used for the allocation size  it's unlikely that evil   JavaScript could cause an integer overflow.    ===  1. Javascript (V8) Core Memory Integer Vulnerabilities    File: v8/src/factory.cc  Function: Several  Problem Type: Memory Corruption  Compromise Type: Remote Sandbox Process Compromise  Severity: High    The core memory allocators in the V8 Javascript engine suffer from numerous   integer overflows and signed-integer related problems. The problematic   functions are as follows:    Factory::NewFixedArray()  Factory::NewFixedArrayWithHoles()  Factory::NewStringDictionary()  Factory::NewNumberDictionary()  Factory::NewDescriptorArray()    Each of these functions deal with negative size parameters incorrectly at   lower layers (this will be discussed shortly). Note that each of these   functions has an ASSERT() statement ensuring the size parameter is greater   than 0  but these are not compiled in to release versions of Chrome. These   functions are basically just wrappers to lower level memory allocation   functions  mainly:    Heap::AllocateFixedArray()  Heap::AllocateFixedArrayWithHoles()  HashTable&lt;Shape  Key&gt;::Allocate()    The two AllocateFixedArray() functions call Heap::AllocateRawFixedArray()   which contains an integer overflow when multiplying the requested size in   the call to FixedArray::SizeFor(). It also handles negative integers   incorrectly (due to how the NewSpace::AllocateRaw() functions work). The   latter HashTable::Allocate() function has several potential integer   overflows contained within it - primarily when rounding up the size using   the EntryToIndex() function. Note that there is also a signed comparison   issue in this function - for any negative length that is passed to this   function it will be &quot;rounded up&quot; to 4.    These vulnerabilities can be exploited remotely in at least one place - the   Runtime_ArrayConcat() function in v8/src/runtime.cc. This function   implements the Array.concat() function available in Javascript. By   concatenating numerous large arrays  it is possible to pass any arbitrarily   large integer of the attacker's choosing the various allocation functions    and thus trigger the vulnerabilities. This is subsequently followed by   copying data of the attacker's choosing past the end of the allocated   buffer  potentially resulting in remote excution.    A PoC is attached.  === </pre>
support building wicket offline by resolving DTD references locally    Wicket developers  please give me some comment on this:Some wicket test cases parse XML which refers to an external DTD. An example is org.apache.wicket.protocol.http.WicketFilterTestIt refers to org.apache.wicket.util.file.WebXmlFile will will parse a custom web.xml.The web.xml will make the parser to look up http://java.sun.com/dtd/web-app_2_3.dtdWhen building wicket offline this will cause a network error and the test will fail.I would like to add  org.apache.wicket.util.xml.LocalEntityResolverwhich may contain a set of local entitites to avoid hitting the network.As wicket 1.5 is getting close to final I would like to get some feedback first before putting that into trunk...By adding this like to WebXmlFile network lookup would be avoided. DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = factory.newDocumentBuilder(); builder.setEntityResolver(LocalEntityResolver.getDefault()); // no more network lookups Document document = builder.parse(is);----------------------------------------------------package org.apache.wicket.util.xml;import org.apache.wicket.util.lang.Args;import org.xml.sax.EntityResolver;import org.xml.sax.InputSource;import org.xml.sax.SAXException;import javax.servlet.Filter;import java.io.IOException;import java.io.InputStream;import java.util.HashMap;import java.util.Map;/** entity resolver that tries to locate a document type definition (DTD) using a set of custom entity resolvers * @author pete */public class LocalEntityResolver implements EntityResolver{ private final Map&lt;EntityKey  EntityLocator&gt; entities = new HashMap&lt;EntityKey  EntityLocator&gt;(3); public static LocalEntityResolver getDefault() { LocalEntityResolver resolver = new LocalEntityResolver(); // // look up servlet 2.3 web.xml DTD right from inside servlet-api.jar // resolver.put(new EntityKey('-//Sun Microsystems  Inc.//DTD Web Application 2.3//EN'  'http://java.sun.com/dtd/web-app_2_3.dtd')  new ServletApiEntityLocator('web-app_2_3.dtd')); return resolver; } public void put(EntityKey key  EntityLocator locator) { Args.notNull(key  'key'); Args.notNull(locator  'locator'); entities.put(key  locator); } public InputSource resolveEntity(String id  String url) throws SAXException  IOException { for (Map.Entry&lt;EntityKey  EntityLocator&gt; entry : entities.entrySet()) if (entry.getKey().id.equals(id) || entry.getKey().url.equals(url)) return entry.getValue().locateInputSource(); return null; } public static class EntityKey { private final String id; private final String url; private EntityKey(String id  String url) { Args.notEmpty(id  'id'); Args.notEmpty(url  'url'); this.id = id; this.url = url; } @Override public boolean equals(Object o) { if (this == o) return true; if (!(o instanceof EntityKey)) return false; EntityKey key = (EntityKey) o; if (!id.equals(key.id)) return false; return url.equals(key.url); } @Override public int hashCode() { int result = id.hashCode(); result = 31 * result + url.hashCode(); return result; } } public static interface EntityLocator { InputSource locateInputSource() throws SAXException  IOException; } public static class ServletApiEntityLocator implements EntityLocator { private final String name; private ServletApiEntityLocator(String name) { this.name = name; } public InputSource locateInputSource() { InputStream stream = Filter.class.getResourceAsStream('resources/' + name); if (stream == null) return null; return new InputSource(stream); } }}   
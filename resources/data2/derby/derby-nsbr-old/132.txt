in place table/index compress which returns space to OS    Each derby table or index is stored in a separate file. Space fromdeleted rows is eventually reclaimed within the file as is used forsubsequent inserts into the same file. That space is not returned tothe OS unless the user calls the SYSCS_UTIL.SYSCS_COMPRESS_TABLEsystem procedure. That procedure will return the unused space inthe tables and indexes to the OS. It gets an exclusive lock on thetable  copies all rows in the indexes and the base table into newcompressed files and delete the old files. Prior to jdk 1.4 this wasthe only way to return space from a file to the OS.In jdk 1.4 RandomAccessFile was enhanced to allow the truncation of afile  which would return the space at the 'end' of the file back tothe OS. In order to take advantage of this new feature a newcompress feature is needed in derby.The assumption is that this work will be used in future work which willautomatically schedule this job and others in background  with nointeraction needed from the dba. The 1st phase of this work willsimply build a procedure that will do the work. The 2nd phase willbe to look into scheduling the procedure automatically as part ofthe current background post commit processing. Longer term it wouldbe best if this fit into a new background task monitor  which couldschedule larger background tasks balanced against the other prioritiesof the system. These tasks might include: this new online compress automatic statistics gathering  more proactive deleted row reclamation  ....The proposed feature will reorganize base tables and indexes  movingempty pages to the 'end'. It will release space back to the operatingsystem when it has created a chunk of empty pages at the end of thefile. It will be designed to run in background  and will lock resourcesof the table for as short a time as possible so that it can iterativelyprocess the table.To reclaim space in the heap  it will scan the heap in page reverse order.It will get a short term table lock  process all the rows on a page  andthen commit that transaction releasing the lock. The commit will beoptimized like other internal transactions  and will not need to waitfor a synchonized write. Each row moved  will require all the indexentries for that row to also be updated. While doing the processing itwill also take care of processing committed deleted rows. When spaceis free at the end of the table it will be freed back to the operatingsystem  using the RandomAccessFile.setLength() interface.To reclaim space in the btree  data on pages will be moved rather thanrows. Data from pages at the end of the file will be moved to freesmaller numbered pages. Again short term table locks will be required and the operation will look similar to the current btree merge operationsalready implemented. Again when a chunk of pages is free at the end ofthe file  they will be returned to the OS using the same mechanism asthe heap.   
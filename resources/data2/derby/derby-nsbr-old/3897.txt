SQLSessionContext not correctly initialized in some non-method call nested contexts    In some contexts  beside calling stored routines containing SQL  Derbyuses nested execution contexts  wehere we have two nested activations but no nested connections.In such cases  currently a new SQLSessionContext is constructed  butnot initialized correctly. This leads to the session variablesCURRENT_ROLE/CURRENT_SCHEMA not being set correctly in these contexts(they should inherited from the parent context  cf DERBY-3327).For method calls  this is being handled by generating a call tolcc.setupNestedSessionContext (seeStaticMethodCallNode#generateSetupNestedSessionContext)In some of these nested contexts  one or both of the session variablesCURRENT_ROLE/CURRENT_SCHEMA can be referenced  in othersnot. Obviously  if they can  this will lead to errors. The followingcontexts will have this problem: ALTER TABLE ADD COLUMN &lt;colname&gt; &lt;coltype&gt; DEFAULT CURRENT_ROLE In the AlterTableConstantAction  a nested UPDATE statement is used to give existing rows the new column its default value. This execution context is nested  cf. AlterTableConstantAction#executeUpdate TRIGGER body execution may reference CURRENT_ROLE/CURRENT_SCHEMA. The body executes in a nested context  cf. GenericTriggerExecutor#executeSPS.In other cases  the session variables can not be referenced  so thisnot a problem:  CHECK constraint execution when executed as part of an ALTER TABLE EmbedResultSet.insertRow  .deleteRow  .updateRowThe session context should not be changed (pushed) for these nestedexecutions  since there is no nested connection (SQL 2003  4.37.1: 'AnSQL-session is associated with an SQL-connection.')   